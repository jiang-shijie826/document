### 2.1.知识点汇总

超详细导图地址:[jvm思维导图](https://www.processon.com/view/link/5eea141cf346fb1ae56a44e7)

![在这里插入图片描述](https://img-blog.csdnimg.cn/1812741509b1471a9c2a64073f57535e.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA55m95aSn6ZSF,size_20,color_FFFFFF,t_70,g_se,x_16)

### 2.2.知识点详解：

**1、JVM内存模型：**

线程独占:栈,本地方法栈,程序计数器

线程共享:堆,方法区

**2、栈：**

又称方法栈,线程私                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    有的,线程执行方法是都会创建一个栈帧,用来存储局部变量表,操作栈,动态链接,方法

出口等信息.调用方法时执行入栈,方法返回时执行出栈.

**3、本地方法栈**

与栈类似,也是用来保存执行方法的信息.执行Java方法时使用栈,执行Native方法时使用本地方法栈.

**4、程序计数器**

保存着当前线程执行的字节码位置,每个线程工作时都有独立的计数器,只为执行Java方法服务,执行Native方法时,程序计数器为空.

**5、堆**

JVM内存管理最大的一块,被线程共享,目的是存放对象的实例,几乎所有的对象实例都会放在这里,当堆没有可用空间时,会抛出OOM异常.根据对象的存活周期不同,JVM把对象进行分代管理,由垃圾回收器进行垃圾的回收管理

**6、方法区：**

又称非堆区,用于存储已被虚拟机加载的类信息,常量,静态变量,即时编译器优化后的代码等数据.1.7的永久代和1.8的元空间都是方法区的一种实现

**7、JVM 内存可见性**

JMM是定义程序中变量的访问规则,线程对于变量的操作只能在自己的工作内存中进行,而不能直接对主内存操作.由于指令重排序,读写的顺序会被打乱,因此JMM需要提供原子性,可见性,有序性保证

### 2.3.类加载与卸载

**加载过程:**

![在这里插入图片描述](https://img-blog.csdnimg.cn/9bb5e9a484f444ce80748ff1e9096074.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA55m95aSn6ZSF,size_20,color_FFFFFF,t_70,g_se,x_16)

> 其中**验证**,**准备**,**解析**合称链接
>
> **加载**通过类的完全限定名,查找此类字节码文件,利用字节码文件创建Class对象.
>
> **验证**确保Class文件符合当前虚拟机的要求,不会危害到虚拟机自身安全.
>
> **准备**进行内存分配,为static修饰的类变量分配内存,并设置初始值(0或null).不包含final修饰的静态变量,因为final变量在编译时分配.
>
> **解析**将常量池中的符号引用替换为直接引用的过程.直接引用为直接指向目标的指针或者相对偏移量等.
>
> **初始化**主要完成静态块执行以及静态变量的赋值.先初始化父类,再初始化当前类.只有对类主动使用时才会初始化.

触发条件包括,创建类的实例时,访问类的静态方法或静态变量的时候,使用Class.forName反射类的时候,或者某个子类初始化的时候.
Java自带的加载器加载的类,在虚拟机的生命周期中是不会被卸载的,只有用户自定义的加载器加载的类才可以被卸.

**1、加载机制-双亲委派模式**

双亲委派模式,即加载器加载类时先把请求委托给自己的父类加载器执行,直到顶层的启动类加载器.父类加载器能够完成加载则成功返回,不能则子类加载器才自己尝试加载.

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210121111654229.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTA2MzQwNjY=,size_16,color_FFFFFF,t_70)

优点:

> 1.避免类的重复加载
>
> 2.避免Java的核心API被篡改

**2、分代回收**

分代回收基于两个事实:大部分对象很快就不使用了,还有一部分不会立即无用,但也不会持续很长时间.

> 年轻代->标记-复制
>
> 老年代->标记-清除

**3、回收算法**

a、G1算法(jdk1.9后默认的垃圾回收算法)

**特点：**

保持高回收率的同时减少停顿.采用每次只清理一部分,而不是清理全部的增量式清理,以保证停顿时间不会过长。其取消了年轻代与老年代的物理划分,但仍属于分代收集器,算法将堆分为若干个逻辑区域(region),一部分用作年轻代,一部分用作老年代,还有用来存储巨型对象的分区，同CMS相同,会遍历所有对象,标记引用情况,清除对象后会对区域进行复制移动,以整合碎片空间。

* 年轻代回收:
  * 并行复制采用复制算法,并行收集,会StopTheWorld.
* 老年代回收:
  * 会对年轻代一并回收
  * 初始标记完成堆root对象的标记,会StopTheWorld.
  * 并发标记 GC线程和应用线程并发执行.
  * 最终标记完成三色标记周期,会StopTheWorld.
  * 复制/清除会优先对可回收空间加大的区域进行回收

b、ZGC算法

前面提供的高效垃圾回收算法,针对大堆内存设计,可以处理TB级别的堆,可以做到10ms以下的回收停顿时间

> 着色指针
>
> 读屏障
>
> 并发处理
>
> 基于region
>
> 内存压缩(整理)

**roots标记：**标记root对象,会StopTheWorld.

**并发标记：**利用读屏障与应用线程一起运行标记,可能会发生StopTheWorld.清除会清理标记为不可用的对象.

**roots重定位：**是对存活的对象进行移动,以腾出大块内存空间,减少碎片产生.重定位最开始会StopTheWorld,取决于重定位集与对象总活动集的比例.并发重定位与并发标记类似.

### 2.4.简述一下JVM的内存模型

1.JVM内存模型简介

JVM定义了不同运行时数据区，他们是用来执行应用程序的。某些区域随着JVM启动及销毁，另外一些区域的数据是线程性独立的，随着线程创建和销毁

**线程私有区**

> 1、程序计数器
>
> 当同时进行的线程数超过CPU数或其内核数时，就要通过时间片轮询分派CPU的时间资源，不免发生线程切换。这时，每个线程就需要一个属于自己的计数器来记录下一条要运行的指令。如果执行的是JAVA方法，计数器记录正在执行的java字节码地址，如果执行的是native方法，则计数器为空。
>
> 2、虚拟机栈
>
> 线程私有的，与线程在同一时间创建。管理JAVA方法执行的内存模型。每个方法执行时都会创建一个桢栈来存储方法的的变量表、操作数栈、动态链接方法、返回值、返回地址等信息。
>
> 栈的大小决定了方法调用的可达深度（递归多少层次，或嵌套调用多少层其他方法，-Xss参数可以设置虚拟机栈大小）。栈的大小可以是固定的，或者是动态扩展的。如果请求的栈深度大于最大可用深度，则抛出stackOverflowError；如果栈是可动态扩展的，但没有内存空间支持扩展，则抛出OutofMemoryError。
>
> 3、本地方法栈
>
> 与虚拟机栈作用相似。但它不是为Java方法服务的，而是本地方法（C语言）。由于规范对这块没有强制要求，不同虚拟机实现方法不同。

**线程共享区**

> 1、方法区
>
> 线程共享的，用于存放被虚拟机加载的类的元数据信息，如常量、静态变量和即时编译器编译后的代码。若要分代，算是永久代（老年代），以前类大多“static”的，很少被卸载或收集，现回收废弃常量和无用的类。其中运行时常量池存放编译生成的各种常量。（如果hotspot虚拟机确定一个类的定义信息不会被使用，也会将其回收。回收的基本条件至少有：所有该类的实例被回收，而且装载该类的ClassLoader被回收）
>
> 2、堆
>
> 存放对象实例和数组，是垃圾回收的主要区域，分为新生代和老年代。刚创建的对象在新生代的Eden区中，经过GC后进入新生代的S0区中，再经过GC进入新生代的S1区中，15次GC后仍存在就进入老年代。这是按照一种回收机制进行划分的，不是固定的。若堆的空间不够实例分配，则OutOfMemoryError。

### 2.5.堆和栈的区别

栈是运行时单位，代表着逻辑，内含基本数据类型和堆中对象引用，所在区域连续，没有碎片；

堆是存储单位，代表着数据，可被多个栈共享（包括成员中基本数据类型、引用和引用对象），所在区域不连续，会有碎片。

* **功能不同**
  栈内存用来存储局部变量和方法调用，而堆内存用来存储Java中的对象。无论是成员变量，局部变量，还是类变量，它们指向的对象都存储在堆内存中。

* **共享性不同**
  栈内存是线程私有的。
  堆内存是所有线程共有的。
* **异常错误不同**
  如果栈内存或者堆内存不足都会抛出异常。
  栈空间不足：java.lang.StackOverFlowError。
  堆空间不足：java.lang.OutOfMemoryError。
* **空间大小**
  栈的空间大小远远小于堆的

### 2.6.什么时候会触发FullGC

> （1）调用System.gc时，系统建议执行Full GC，但是不必然执行
>
> （2）老年代空间不足
>
> （3）方法区(1.8之后改为元空间)空间不足
>
> （4）创建大对象，比如数组，通过Minor GC后，进入老年代的平均大小大于老年代的可用内存
>
> （5）由Eden区、From Space区向To Space区复制时，对象大小大于To Space可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小。

除直接调用System.gc外，触发Full GC执行的情况有如下四种。

**1.旧生代空间不足**

旧生代空间只有在新生代对象转入及创建为大对象、大数组时才会出现不足的现象，当执行Full GC后空间仍然不足，则抛出如下错误：java.lang.OutOfMemoryError: Java heap space为避免以上两种状况引起的FullGC，调优时应尽量做到让对象在Minor GC阶段被回收、让对象在新生代多存活一段时间及不要创建过大的对象及数组。

**2.Permanet Generation空间满**

PermanetGeneration中存放的为一些class的信息等，当系统中要加载的类、反射的类和调用的方法较多时，Permanet Generation可能会被占满，在未配置为采用CMS GC的情况下会执行Full GC。如果经过Full GC仍然回收不了，那么JVM会抛出如下错误信息：java.lang.OutOfMemoryError: PermGen space

为避免Perm Gen占满造成Full GC现象，可采用的方法为增大Perm Gen空间或转为使用CMS GC。

**3.CMS GC时出现promotion failed和concurrent mode failure**

对于采用CMS进行旧生代GC的程序而言，尤其要注意GC日志中是否有promotion failed和concurrent mode failure两种状况，当这两种状况出现时可能会触发Full GC。promotionfailed是在进行Minor GC时，survivor space放不下、对象只能放入旧生代，而此时旧生代也放不下造成的；concurrent mode failure是在执行CMS GC的过程中同时有对象要放入旧生代，而此时旧生代空间不足造成的。

**应对措施为：增大survivorspace、旧生代空间或调低触发并发GC的比率，但在JDK 5.0+、6.0+的版本中有可能会由于JDK的bug导致CMS在remark完毕后很久才触发sweeping动作。对于这种状况，可通过设置-XX:CMSMaxAbortablePrecleanTime=5（单位为ms）来避免。**

**4.统计得到的Minor GC晋升到旧生代的平均大小大于旧生代的剩余空间**

这是一个较为复杂的触发情况，Hotspot为了避免由于新生代对象晋升到旧生代导致旧生代空间不足的现象，在进行Minor GC时，做了一个判断，如果之前统计所得到的Minor GC晋升到旧生代的平均大小大于旧生代的剩余空间，那么就直接触发Full GC。

例如程序第一次触发MinorGC后，有6MB的对象晋升到旧生代，那么当下一次Minor GC发生时，首先检查旧生代的剩余空间是否大于6MB，如果小于6MB，则执行Full GC。当新生代采用PSGC时，方式稍有不同，PS GC是在Minor GC后也会检查，例如上面的例子中第一次Minor GC后，PS GC会检查此时旧生代的剩余空间是否大于6MB，如小于，则触发对旧生代的回收。

除了以上4种状况外，对于使用RMI来进行RPC或管理的Sun JDK应用而言，默认情况下会一小时执行一次Full GC。可通过在启动时通过- java Dsun.rmi.dgc.client.gcInterval=3600000来设置Full GC执行的间隔时间或通过-XX:+ DisableExplicitGC来禁止RMI调用System.gc。

### 2.7.什么是Java虚拟机？为什么Java被称作是“平台无关的编程语言”？

Java虚拟机是一个可以执行Java字节码的虚拟机进程。Java源文件被编译成能被Java虚拟机执行的字节码文件。 Java被设计成允许应用程序可以运行在任意的平台，而不需要程序员为每一个平台单独重写或者是重新编译。Java虚拟机让这个变为可能，因为它知道底层硬件平台的指令长度和其他特性。

### 2.8.Java内存结构

方法区和堆是所有线程共享的内存区域；而java栈、本地方法栈和程序员计数器是运行时线程私有的内存区域。

> Java堆(Heap):是Java虚拟机所管理的内存中最大的一块。Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。
>
> 方法区(Method Area):方法区（Method Area）与Java堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。
>
> 程序计数器（Program Counter Register）,程序计数器（Program Counter Register）是一块较小的内存空间，它的作用可以看做是当前线程所执行的字节码的信号指示器。
>
> JVM栈(JVM Stacks):与程序计数器一样，Java虚拟机栈（Java Virtual Machine Stacks）也是线程私有的，它的生命周期与线程相同。虚拟机栈描述的是Java方法执行的内存模型：每个方法被执行的时候都会同时创建一个栈帧（Stack Frame）用于存储局部变量表、操作栈、动态链接、方法出口等信息。每一个方法被调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。
>
> 本地方法栈(Native Method Stacks):本地方法栈（Native Method Stacks）与虚拟机栈所发挥的作用是非常相似的，其区别不过是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则是为虚拟机使用到的Native方法服务。

### 2.9.对象分配规则

> * 对象优先分配在Eden区，如果Eden区没有足够的空间时，虚拟机执行一次Minor GC。
>
> * 大对象直接进入老年代（大对象是指需要大量连续内存空间的对象）。这样做的目的是避免在Eden区和两个Survivor区之间发生大量的内存拷贝（新生代采用复制算法收集内存）。
> * 长期存活的对象进入老年代。虚拟机为每个对象定义了一个年龄计数器，如果对象经过了1次Minor GC那么对象会进入Survivor区，之后每经过一次Minor GC那么对象的年龄加1，直到达到阀值对象进入老年区。
> * 动态判断对象的年龄。如果Survivor区中相同年龄的所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象可以直接进入老年代。
> * 空间分配担保。每次进行Minor GC时，JVM会计算Survivor区移至老年区的对象的平均大小，如果这个值大于老年区的剩余值大小则进行一次Full GC，如果小于检查HandlePromotionFailure设置，如果true则只进行Monitor GC,如果false则进行Full GC。

### 2.10.Java对象创建过程

1. JVM遇到一条新建对象的指令时首先去检查这个指令的参数是否能在常量池中定义到一个类的符号引用。然后加载这个类（类加载过程在后边讲）
2. 为对象分配内存。一种办法“指针碰撞”、一种办法“空闲列表”，最终常用的办法“本地线程缓冲分配(TLAB)”
3. 将除对象头外的对象内存空间初始化为0
4. 对对象头进行必要设置

### 2.11.类的生命周期

类的生命周期包括这几个部分，加载、链接、初始化、使用和卸载，其中前三部是类的加载的过程加载，查找并加载类的二进制数据，在Java堆中也创建一个`java.lang.Class`类的对象连接，链接又包含三块内容：验证、准备、初始化。

> 1）验证，文件格式、元数据、字节码、符号引用验证；
>
> 2）准备，为类的静态变量分配内存，并将其初始化为默认值；
>
> 3）解析，把类中的符号引用转换为直接引用初始化，为类的静态变量赋予正确的初始值使用，new出对象程序中使用卸载，执行垃圾回收

### 2.12.简述Java的对象结构

Java对象由三个部分组成：对象头、实例数据、对齐填充。

**对象头：**

第一部分存储对象自身的运行时数据：哈希码、GC分代年龄、锁标识状态、线程持有的锁、偏向线程ID（一般占32/64 bit）。

第二部分是指针类型，指向对象的类元数据类型（即对象代表哪个类）。如果是数组对象，则对象头中还有一部分用来记录数组长度。

**实例数据：**

用来存储对象真正的有效信息（包括父类继承下来的和自己定义的）

**对齐填充**：

JVM要求对象起始地址必须是8字节的整数倍（8字节对齐）

### 2.13.如何判断对象可以被回收？

判断对象是否存活一般有两种方式：

**引用计数：**每个对象有一个引用计数属性，新增一个引用时计数加1，引用释放时计数减1，计数为0时可以回收。此方法简单，无法解决对象相互循环引用的问题。

**可达性分析（Reachability Analysis）：**从GC Roots开始向下搜索，搜索所走过的路径称为引用链。当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的，不可达对象。

### 2.14.JVM的永久代中会发生垃圾回收么？

垃圾回收不会发生在永久代，如果永久代满了或者是超过了临界值，会触发完全垃圾回收(Full GC)。如果你仔细查看垃圾收集器的输出信息，就会发现永久代也是被回收的。这就是为什么正确的永久代大小对避免Full GC是非常重要的原因。请参考下Java8：从永久代到元数据区 (注：Java8中已经移除了永久代，新加了一个叫做元数据区的native内存区)

### 2.15.垃圾收集算法

GC最基础的算法有三种： 标记 -清除算法、复制算法、标记-压缩算法，我们常用的垃圾回收器一般都采用分代收集算法。

* 标记-清除（Mark-sweep）:标记清除算法分为两个阶段，标记阶段和清除阶段。标记阶段任务是标记出所有需要回收的对象，清除阶段就是清除被标记对象的空间。

  `优缺点：实现简单，容易产生内存碎片`

* 复制（Copying）将可用内存划分为大小相等的两块，每次只使用其中的一块。当进行垃圾回收的时候了，把其中存活对象全部复制到另外一块中，然后把已使用的内存空间一次清空掉。 

  `优缺点：不容易产生内存碎片；可用内存空间少；存活对象多的话，效率低下。`

* 标记-整理（Mark-Compact）先标记存活对象，然后把存活对象向一边移动，然后清理掉端边界以外的内存 

  `优缺点：不容易产生内存碎片；内存利用率高；存活对象多并且分散的时候，移动次数多，效率低下`

* 分代收集算法(目前大部分JVM的垃圾收集器所采用的算法）
  * `年轻代（Young Generation）`的回收算法 (回收主要以Copying为主)
  * `年老代（Old Generation）`的回收算法（回收主要以Mark-Compact为主）


### 2.16.调优命令有哪些？

详情查看此文:[jvm调优](https://baidaguo.blog.csdn.net/article/details/121397268?spm=1001.2014.3001.5502)
Sun JDK监控和故障处理命令有

> **jps:** JVM Process Status Tool,显示指定系统内所有的HotSpot虚拟机进程。
>
> **jstat:** JVM statistics Monitoring是用于监视虚拟机运行时状态信息的命令，它可以显示出虚拟机进程中的类装载、内存、垃圾收集、JIT编译等运行数据。
>
> **jmap:** JVM Memory Map命令用于生成heap dump文件
>
> **jhat: **JVM Heap Analysis Tool命令是与jmap搭配使用，用来分析jmap生成的dump，jhat内置了一个微型的HTTP/HTML服务器，生成dump的分析结果后，可以在浏览器中查看
>
> **jstack:** 用于生成java虚拟机当前时刻的线程快照。
>
> **jinfo： **JVM Configuration info 这个命令作用是实时查看和调整虚拟机运行参数。

### 2.17.调优工具

常用调优工具分为两类,jdk自带监控工具：jconsole和jvisualvm，第三方有：MAT(Memory Analyzer Tool)、GChisto。

> **jconsole:**Java Monitoring and Management Console是从java5开始，在JDK中自带的java监控和管理控制台，用于对JVM中内存，线程和类等的监控
>
> **jvisualvm:**jdk自带全能工具，可以分析内存快照、线程快照；监控内存变化、GC变化等。
>
> **MAT:**Memory Analyzer Tool，一个基于Eclipse的内存分析工具，是一个快速、功能丰富的Java heap分析工具，它可以帮助我们查找内存泄漏和减少内存消耗
>
> **GChisto:**一款专业分析gc日志的工具

### 2.18.Minor GC与Full GC分别在什么时候发生？

新生代内存不够用时候发生MGC也叫YGC，JVM内存不够的时候发生FGC

### 2.19.你知道哪些JVM性能调优

**设定堆内存大小**

> -Xmx：堆内存最大限制。

**设定新生代大小。** 新生代不宜太小，否则会有大量对象涌入老年代

> -XX:NewSize：新生代大小
>
> -XX:NewRatio 新生代和老生代占比
>
> -XX:SurvivorRatio：伊甸园空间和幸存者空间的占比

**设定垃圾回收器** 

> 年轻代用 -XX:+UseParNewGC 
>
> 年老代用-XX:+UseConcMarkSweepGC

### 2.20.简述Java垃圾回收机制?

在Java中，程序员是不需要显式的去释放一个对象的内存的，而是由虚拟机自行执行。在JVM中，有一个垃圾回收线程，它是低优先级的，在正常情况下是不会执行的，只有在虚拟机空闲或者当前堆内存不足时，才会触发执行，扫描那些没有被任何引用的对象，并将它们添加到要回收的集合中，进行回收

### 2.21.什么是类加载器，类加载器有哪些?

实现通过类的全限定名获取该类的二进制字节流的代码块叫做类加载器。

主要有一下四种类加载器:

1. 启动类加载器(Bootstrap ClassLoader):用来加载java核心类库，无法被java程序直接引用。
2. 扩展类加载器(extensions class loader):它用来加载 Java 的扩展库。Java 虚拟机的实现会提供一个扩展库目录。该类加载器在此目录里面查找并加载 Java 类。
3. 系统类加载器(system class loader):它根据 Java 应用的类路径(CLASSPATH）来加载 Java类。一般来说，Java 应用的类都是由它来完成加载的。可以通过ClassLoader.getSystemClassLoader()来获取它。
4. 用户自定义类加载器，通过继承 java.lang.ClassLoader类的方式实现。

* **由不同的类加载器加载的指定类型还是相同的类型吗（不同）**

> 在Java中，一个类用其完全匹配类名(fully qualified class name)作为标识，这里指的完全匹配类名包括包名和类名。但在JVM中一个类用其全名和一个加载类ClassLoader的实例作为唯一标识，不同类加载器加载的类将被置于不同的命名空间。所以是不相同的

* **在代码中直接调用Class.forName（String name）方法，到底会触发哪个类加载器进行类加载行为？**

> Class.forName(String name)默认会使用调用类的类加载器来进行类加载

* **在编写自定义类加载器时，如果没有设定父加载器，那么父加载器是?**

> 在不指定父类加载器的情况下，默认采用系统类加载器(AppClassLoader);

* **编写自定义类加载器时，一般有哪些注意点？**

> 一般尽量不要覆写已有的loadClass（…）方法中的委派逻辑; 这样做极有可能引起系统默认的类加载器不能正常工作

* **如何在运行时判断系统类加载器能加载哪些路径下的类？**

> 一 、是可以直接调用ClassLoader.getSystemClassLoader()或者其他方式获取到系统类加载器（系统类加载器和扩展类加载器本身都派生自URLClassLoader），`调用URLClassLoader中的getURLs()方法可以获取到`
>
> 二 、是可以直接通过获取系统属性java.class.path 来查看当前类路径上的条目信息 ，`System.getProperty("java.class.path")`

* **在Java的反射中，Class.forName和ClassLoader的区别**

> ClassLoader就是遵循双亲委派模型最终调用启动类加载器的类加载器
>
> Class.forName()方法实际上也是调用的CLassLoader来实现的;在这个forName0方法中的第二个参数被默认设置为了true，这个参数代表是否对加载的类进行初始化，设置为true时会对类进行初始化，代表会执行类中的静态代码块，以及对静态变量的赋值等操作。
>
> `Class.forName 默认会进行初始化，执行静态代码块；有参数可以设置`

### 2.22.你有没有遇到过OutOfMemory问题？你是怎么来处理这个问题的？处理 过程中有哪些收获？

**常见的原因:**

* 内存加载的数据量太大：一次性从数据库取太多数据；
* 集合类中有对对象的引用，使用后未清空，GC不能进行回收；
* 代码中存在循环产生过多的重复对象；
* 启动参数堆内存值小。

### 2.23.JDK 1.8之后Perm Space有哪些变动? MetaSpace⼤⼩默认是⽆限的么? 还是你们会通过什么⽅式来指定⼤⼩?

* JDK 1.8后用元空间替代了 Perm Space；字符串常量存放到堆内存中。
* MetaSpace大小默认没有限制，一般根据系统内存的大小。JVM会动态改变此值。
* `-XX:MetaspaceSize`：分配给类元数据空间（以字节计）的初始大小（Oracle逻辑存储上的初始高水位，the initial high-water-mark）。此值为估计值，MetaspaceSize的值设置的过大会延长垃圾回收时间。垃圾回收过后，引起下一次垃圾回收的类元数据空间的大小可能会变大。
* `-XX:MaxMetaspaceSize`：分配给类元数据空间的最大值，超过此值就会触发Full GC，此值默认没有限制，但应取决于系统内存的大小。JVM会动态地改变此值。

### 2.24  什么时候会发生内存泄露？让你写一段内存泄露的代码你会怎么写？

[JAVA 内存泄露详解（原因、例子及解决）]: https://blog.csdn.net/anxpp/article/details/51325838	"JAVA 内存泄露详解（原因、例子及解决）"
[Java中关于内存泄漏出现的原因以及如何避免内存泄漏]: https://blog.csdn.net/wtt945482445/article/details/52483944?utm_source=blogxgwz8	"Java中关于内存泄漏出现的原因以及如何避免内存泄漏"

> 我们知道，对象都是有生命周期的，有的长，有的短，如果长生命周期的对象持有短生命周期的引用，就很可能会出现内存泄露

下面给出一个 Java 内存泄漏的典型例子

```java
Vector v = new Vector(10);
for (int i = 0; i < 100; i++) {
    Object o = new Object();
    v.add(o);
    o = null;
}
```

在这个例子中，我们循环申请Object对象，并将所申请的对象放入一个 Vector 中，如果我们仅仅释放引用本身，那么 Vector 仍然引用该对象，所以这个对象对 GC 来说是不可回收的。因此，如果对象加入到Vector 后，还必须从 Vector 中删除，最简单的方法就是将 Vector 对象设置为 null。

`v = null`

**ThreadLocal使用不当也可能泄漏**

### 2.25 Java 内存模型中的 happen-before 是什么？

> 从 JDK5 开始，java 使用新的 JSR -133 内存模型,提出了 happens-before 的概念（如果一个操作执行的结果需要对另一个操作可见，那么这两个操作之间必须存在 happens-before 关系）这里提到的两个操作既可以是在一个线程之内，也可以是在不同线程之间
> 
>* 程序顺序规则：一个线程中的每个操作，happens- before 于该线程中的任意后续操作。
> 
>* 监视器锁规则：对一个监视器锁的解锁，happens- before 于随后对这个监视器锁的加锁。
> * volatile 变量规则：对一个 volatile 域的写，happens- before 于任意后续对这个 volatile 域的读。
>* 传递性：如果 A happens- before B，且 B happens- before C，那么 A happens- before C。

**注意，两个操作之间具有 happens-before 关系，并不意味着前一个操作必须要在后一个操作之前执行！**

### 2.26 **GC机制**简要说明一下，不同区使用的算法。

> `年轻代：`是所有新对象产生的地方。年轻代被分为3个部分——Enden区和两个Survivor区（From和to）当Eden区被对象填满时，就会执行Minor GC。并把所有存活下来的对象转移到其中一个survivor区（假设为from区）。Minor GC同样会检查存活下来的对象，并把它们转移到另一个survivor区（假设为to区）。这样在一段时间内，总会有一个空的survivor区。经过多次GC周期后，仍然存活下来的对象会被转移到年老代内存空间。通常这是在年轻代有资格提升到年老代前通过设定年龄阈值来完成的。需要注意，Survivor的两个区是对称的，没先后关系，from和to是相对的。
>
> `年老代：`在年轻代中经历了N次回收后仍然没有被清除的对象，就会被放到年老代中，可以说他们都是久经沙场而不亡的一代，都是生命周期较长的对象。对于年老代和永久代，就不能再采用像年轻代中那样搬移腾挪的回收算法，因为那些对于这些回收战场上的老兵来说是小儿科。通常会在老年代内存被占满时将会触发Full GC,回收整个堆内存。
>
> `持久代：`用于存放静态文件，比如java类、方法等。持久代对垃圾回收没有显著的影响
>
> ![在这里插入图片描述](https://img-blog.csdnimg.cn/20210112175439258.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTA2MzQwNjY=,size_16,color_FFFFFF,t_70)

#### **两个对象循环引用会不会被被GC？**

> GC里边在JVM当中是使用的ROOT算法，ROOT算法 也就是根; 只要看这个两个对象有没有挂在 根 上, 挂在根上了 就不会被回收; 没有挂在根上就会回收;

#### 哪些可以算作根节点？

> 1. 方法区中的静态属性
> 2. 方法区的中的常量
> 3. 虚拟机中的局部变量
> 4. 本地方法栈中JNI

### 2.27 垃圾收集器 G1有什么样的特性了解吗？ CMS呢？

> [CMS与G1的优缺点](https://blog.csdn.net/zhou2s_101216/article/details/79219953)

**CMS垃圾回收器：**

> 1. 初始标记(CMS-initial-mark) ,会导致STW(stop-the-world)；
>
> 2. 并发标记(CMS-concurrent-mark)，与用户线程同时运行
>
> 3. 预清理（CMS-concurrent-preclean），与用户线程同时运行
>
> 4. 可被终止的预清理（CMS-concurrent-abortable-preclean） 与用户线程同时运行；
>
> 5. 重新标记(CMS-remark) ，会导致STW； 这个阶段会导致第二次stop the word，该阶段的任务是完成标记整个年老代的所有的存活对象。
>
>    这个阶段，重新标记的内存范围是整个堆，包含_young_gen和_old_gen。为什么要扫描新生代呢，因为对于老年代中的对象，如果被新生代中的对象引用，那么就会被视为存活对象，即使新生代的对象已经不可达了
>
> 6. 并发清除(CMS-concurrent-sweep)，与用户线程同时运行；

**CMS垃圾回收器的优化**

> `减少重新标记remark阶段停顿`
> 一般CMS的GC耗时 80%都在remark阶段，如果发现remark阶段停顿时间很长，可以尝试添加该参数：
>
> -XX:+CMSScavengeBeforeRemark
>
> 在执行remark操作之前先做一次ygc，目的在于减少ygen对oldgen的无效引用，降低remark时的开销。

**G1垃圾回收器**

#### CMS收集器和G1收集器的区别

> `区别一： 使用范围不一样`
>
> CMS收集器是老年代的收集器，可以配合新生代的Serial和ParNew收集器一起使用
>
> G1收集器收集范围是老年代和新生代。不需要结合其他收集器使用
>
> `区别二： STW的时间`
>
> CMS收集器以最小的停顿时间为目标的收集器。
>
> G1收集器可预测垃圾回收的停顿时间（建立可预测的停顿时间模型）
>
> `区别三： 垃圾碎片`
>
> CMS收集器是使用“标记-清除”算法进行的垃圾回收，容易产生内存碎片
>
> G1收集器使用的是“标记-整理”算法，进行了空间整合，降低了内存空间碎片。

### 2.28 平时有没有遇到一些栈溢出或者内存溢出，内存泄露的问题吗？如何去分析这个问题？

> `内存泄漏`是指对象实例在新建和使用完毕后，仍然被引用，没能被垃圾回收释放，一直积累，直到没有剩余内存可用。如果内存泄露，我们要找出泄露的对象是怎么被GC ROOT引用起来，然后通过引用链来具体分析泄露的原因。分析内存泄漏的工具有：Jprofiler，visualvm等。
>
> `内存溢出`是指当我们新建一个实例对象时，实例对象所需占用的内存空间大于堆的可用空间。
> 栈（JVM Stack）存放主要是栈帧( 局部变量表, 操作数栈 , 动态链接 , 方法出口信息 )的地方。注意区分栈和栈帧：栈里包含栈帧。与线程栈相关的内存异常有两个：
>
> a）、StackOverflowError(方法调用层次太深，内存不够新建栈帧)
>
> b）、OutOfMemoryError（线程太多，内存不够新建线程）
>
> 如果出现了内存溢出问题，这往往是程序本生需要的内存大于了我们给虚拟机配置的内存，这种情况下，我们可以采用调大-Xmx来解决这种问题

**如果内存猛增，怎么去排查？**

> 通过jstack分析问题
>
> 1、利用top名称查看哪个java进程占用了较多的cpu资源；
>
> 2、通过top -Hp pid可以查看该进程下各个线程的cpu使用情况；
>
> 3、通过top -Hp命令定位到cpu占用率较高的线程tid之后，继续使用jstack pid命令查看当前java进程的堆栈状态
>
> 4、然后将刚刚找到的tid转换成16进制，在 jstack -pid里面的堆栈信息里面找到对应的线程信息

