### 18.1 [select、poll、epoll之间的区别](https://www.cnblogs.com/aspirant/p/9166944.html)

> select，poll，epoll都是IO多路复用的机制。I/O多路复用就通过一种机制，可以监视多个描述符，一旦某个描述符就绪（一般是读就绪或者写就绪），能够通知程序进行相应的读写操作。`但select，poll，epoll本质上都是同步I/O`，因为他们都需要在读写事件就绪后`自己负责进行读写，也就是说这个读写过程是阻塞的`，而异步I/O则无需自己负责进行读写，异步I/O的实现会负责把数据从内核拷贝到用户空间。

> `select: `时间复杂度O(n),它仅仅知道了，有I/O事件发生了，却并不知道是哪那几个流（可能有一个，多个，甚至全部) `select具有O(n)的无差别轮询复杂度`， 同时处理的流越多，无差别轮询时间就越长。**遍历** ； `有最大连接数的限制，在FD_SETSIZE宏定义`
>
> `poll:`时间复杂度O(n),poll本质上和select没有区别，它将用户传入的数组拷贝到内核空间，然后查询每个fd对应的设备状态， 但是它没有最大连接数的限制，原因是它是基于链表来存储的.`但是它没有最大连接数的限制，原因是它是基于链表来存储的`
>
> `epoll `时间复杂度O(1),epoll可以理解为event poll，epoll会把哪个流发生了怎样的I/O事件通知我们。所以我们说epoll实际上是事件驱动（每个事件关联上fd）的 ;`虽然连接数有上限，但是很大，1G内存的机器上可以打开10万左右的连接`

**epoll的优点：**

> 1、没有最大并发连接的限制，能打开的FD的上限远大于1024（1G的内存上能监听约10万个端口）；
>
> 2、效率提升，不是轮询的方式，不会随着FD数目的增加效率下降。只有活跃可用的FD才会调用callback函数；
> 即Epoll最大的优点就在于它只管你“活跃”的连接，而跟连接总数无关，因此在实际的网络环境中，Epoll的效率就会远远高于select和poll。
>
> 3、内存拷贝，利用mmap()文件映射内存加速与内核空间的消息传递；即epoll使用mmap减少复制开销。

### 18.2 BIO、NIO、AIO

#### BIO

> Java BIO 就是传统的 Java IO 编程,同步并阻塞（传统阻塞型），服务器实现模式为一个连接一个线程，即客户端有连接请求时服务器端就需要启动一个线程进行处理，如果这个连接不作任何事情会造成不必要的线程开销。`BIO 方式适用于连接数比较小且固定的架构`
>
> ![在这里插入图片描述](https://img-blog.csdnimg.cn/20210114145919650.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTA2MzQwNjY=,size_16,color_FFFFFF,t_70)



#### NIO

> Java NIO 全称 Java non-blocking IO,NIO `同步非阻塞` 有三大核心部分：`Channel（管道）、Buffer（缓冲区）、Selector（选择器）`。`NIO 以块的方式处理数据`，块 I/O 的效率比流 I/O 高很多
> NIO 是`面向缓冲区编程`的。数据读取到了一个它稍微处理的缓冲区，需要时可在缓冲区中前后移动，这就增加了处理过程中的灵活性，使用它可以提供非阻塞的高伸缩性网络
>
> ![在这里插入图片描述](https://img-blog.csdnimg.cn/20210114150220295.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTA2MzQwNjY=,size_16,color_FFFFFF,t_70)



#### NIO 和 BIO 对比

> 1. BIO 以流的方式处理数据，而 NIO 以块的方式处理数据，块 I/O 的效率比流 I/O 高很多。
> 2. BIO 是阻塞的，而 NIO 是非阻塞的。
> 3. BIO 基于字节流和字符流进行操作，而 NIO 基于 Channel（通道）和 Buffer（缓冲区）进行操作，数据总是从通道读取到缓冲区中，或者从缓冲区写入到通道中。Selector（选择器）用于监听多个通道事件（比如连接请求，数据到达等），因此使用单个线程就可以监听多个客户端通道。
> 4. NIO比传统的BIO核心区别就是，NIO采用的是多路复用的IO模型，普通的IO用的是阻塞的IO模型

#### AIO

> JDK 7 引入了 Asynchronous I/O，即 AIO。在进行 I/O 编程中，通常用到两种模式：Reactor 和 Proactor 。Java 的 NIO 就是 Reactor，当有事件触发时，服务器端得到通知，进行相应的处理。
> AIO 叫做`异步非阻塞的 I/O`，引入了异步通道的概念，采用了 Proactor 模式，简化了程序编写，有效的请求才会启动线程，特点就是先由操作系统完成后才通知服务端程序启动线程去处理，一般用于连接数较多且连接时长较长的应用。

### 18.3 netty是用select 还是 epoll

> 在win下用select 在linux下用epoll

### 18.4 Channel 的基本介绍

> 1. 通道是双向的可以进行读写，而流是单向的只能读，或者写。
> 2. 通道可以实现异步读写数据。
> 3. 通道可以从缓冲区读取数据，也可以写入数据到缓冲区。

### 18.5 说说Reactor线程模型的理解

#### Reactor 单线程

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210119142059448.png)

> 每个客户端发起连接请求都会交给acceptor,acceptor根据事件类型交给线程handler处理，但是由于在同一线程中，容易产生一个handler阻塞影响其他的情况。

#### Reactor 多线程

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210119142136481.png)

> 这里使用了单线程进行接收客户端的连接，采用了NIO的线程池用来处理客户端对应的IO操作，由于客户端连接较多，有时会一个线程对应处理多个连接。

#### Reactor 主从

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210119142216856.png)

> 这里将接收客户端请求后采用线程池进行处理，服务端用于接收客户端连接的不再是个1个单独的NIO线程，而是一个独立的NIO线程池。Acceptor接收到客户端TCP连接请求处理完成后（可能包含接入认证等），将新创建的SocketChannel注册到IO线程池（sub reactor线程池）的某个IO线程上，由它负责SocketChannel的读写和编解码工作。Acceptor线程池仅仅只用于客户端的登陆、握手和安全认证，一旦链路建立成功，就将链路注册到后端subReactor线程池的IO线程上，由IO线程负责后续的IO操作。

### 18.6 [TCP三次握手四次挥手](https://www.cnblogs.com/bj-mr-li/p/11106390.html)

![在这里插入图片描述](https://img-blog.csdnimg.cn/2021020414363193.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTA2MzQwNjY=,size_16,color_FFFFFF,t_70)



> 1. `第一次握手`
>
>    建立连接时，客户端发送syn包（syn=j）到服务器，并进入SYN_SENT状态，等待服务器确认；SYN：同步序列编号（Synchronize Sequence Numbers）
>
> 2. `第二次握手`
>
>    服务器收到syn包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态；
>
> 3. `第三次握手`
>
>    客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=k+1），此包发送完毕，客户端和服务器进入ESTABLISHED（TCP连接成功）状态，完成三次握手。

**四次挥手**

### 四次挥手中TIME_WAIT状态存在的目的是什么?

### TCP是通过什么机制保障可靠性的?

### 18.7 TCP粘包，拆包及解决方法

> 产生粘包和拆包问题的主要原因是，`操作系统在发送TCP数据的时候，底层会有一个缓冲区`，例如1024个字节大小，如果一次请求发送的数据量比较小，没达到缓冲区大小，TCP则会将多个请求合并为同一个请求进行发送，这就形成了粘包问题；如果一次请求发送的数据量比较大，超过了缓冲区大小，TCP就会将其拆分为多次发送，这就是拆包，也就是将一个大的包拆分为多个小包进行发送

> 1. 发送端给每个数据包添加包首部，首部中应该至少包含数据包的长度，这样接收端在接收到数据后，通过读取包首部的长度字段，便知道每一个数据包的实际长度了。
> 2. 发送端将每个数据包封装为固定长度（不够的可以通过补0填充），这样接收端每次从接收缓冲区中读取固定长度的数据就自然而然的把每个数据包拆分开来。
> 3. 可以在数据包之间设置边界，如添加特殊符号，这样，接收端通过这个边界就可以将不同的数据包拆分开。

### 操作系统虚拟内存换页的过程





> 解决问题的能力
>
> 平时会使用设计模式吗？请讲一个使用的情景
>
> 工作中有碰到过线上的问题吗？怎么解决的？
>
> 你有过Jvm调优经验吗？
>
> 你做了这么多系统，是怎么做系统监控的，系统的稳定性？内存满了，磁盘满了，和cpu高了之类的？
>
> 有碰到过数据库死锁的问题吗？怎么解决的？
>
> 算法
>
> 滑动窗口
>
> 反转单链表
>
> 复杂链表复制
>
> 数组a,先单调地址再单调递减，输出数组中不同元素个数。要求：O(1)空间复杂度，不能改变原数组
>
> 给出两个升序数组A、B和长度m、n，求第k个大的数
>
> 给出数组A，长度为n，数组中元素的值位于[0, n - 1]之间，求是否有重复元素
>
> 镜像二叉树
>
> 二叉树多个节点的最近公共祖先
>
> 树的非递归先序遍历。



























> 
