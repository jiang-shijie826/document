**Dubbo缺省协议采用单一长连接和NIO异步通讯**
**适合于小数据量大并发的服务调用，以及服务消费者机器数远大于服务提供者机器数的情况**

### 16.1 dubbo请求流程

> 1. client一个线程调用远程接口，生成一个唯一的ID（比如一段随机字符串，UUID等），Dubbo是使用AtomicLong从0开始累计数字的
> 2. 将打包的方法调用信息（如调用的接口名称，方法名称，参数值列表等），和处理结果的回调对象callback，全部封装在一起，组成一个对象object
> 3. 向专门存放调用信息的全局ConcurrentHashMap里面put(ID, object)
> 4. 将ID和打包的方法调用信息封装成一对象connRequest，使用IoSession.write(connRequest)异步发送出去
> 5. 当前线程再使用callback的get()方法试图获取远程返回的结果，在get()内部，则使用synchronized获取回调对象callback的锁， 再先检测是否已经获取到结果，如果没有，然后调用callback的wait()方法，释放callback上的锁，让当前线程处于等待状态。
> 6. 服务端接收到请求并处理后，将结果（此结果中包含了前面的ID，即回传）发送给客户端，客户端socket连接上专门监听消息的线程收到消息，分析结果，取到ID，再从前面的ConcurrentHashMap里面get(ID)，从而找到callback，将方法调用结果设置到callback对象里。
> 7. 监听线程接着使用synchronized获取回调对象callback的锁（因为前面调用过wait()，那个线程已释放callback的锁了），再notifyAll()，唤醒前面处于等待状态的线程继续执行（callback的get()方法继续执行就能拿到调用结果了），至此，整个过程结束。

### 16.2 dubbo 各个模块？

> Service 业务层：业务代码的接口与实现
>
> config 配置层：对外配置接口，以 ServiceConfig, ReferenceConfig 为中心，可以直接初始化配置类，也可以通过 Spring 解析配置生成配置类。
>
> proxy 服务代理层：服务接口透明代理
>
> registry 注册中心层：封装服务地址的注册与发现
>
> cluster 路由层：封装多个提供者的路由及负载均衡
>
> monitor 监控层：RPC 调用次数和调用时间监控

### 16.3 如果zookeeper挂掉了，dubbo还能正常运行吗？

> 能,本地有保存一份数据；

### 16.4 Dubbo 使用什么通信框架？

> 在 Dubbo 的最新版本，默认使用 Netty4 的版本
> 当然你也可以通过SPI 选择`Netty3 Mina Grizzly`

### 16.5 Dubbo 支持哪些序列化方式？

> 【重要】Hessian2 ：基于 Hessian 实现的序列化拓展。dubbo:// 协议的默认序列化方案
>
> Dubbo ：Dubbo 自己实现的序列化拓展
>
> 还有 `Kryo 、FST、JSON、NativeJava、CompactedJava`

### 16.6 Dubbo 有哪些集群容错策略？

> `Failover Cluster[默认]：` 失败自动重试其他服务的策略。
>
> `Failover Cluster :` 失败自动切换，当出现失败，重试其它服务器。通常用于读操作，但重试会带来更长延迟。可通过 retries=“2” 来设置重试次数(不含第一次)。
>
> `Failfast Cluster:`快速失败，只发起一次调用，失败立即报错。通常用于非幂等性的写操作，比如新增记录。
>
> `Failsafe Cluster: `失败安全，出现异常时，直接忽略。通常用于写入审计日志等操作
>
> `Failback Cluster: `失败自动恢复，后台记录失败请求，定时重发。通常用于消息通知操作。
>
> `Forking Cluster:` 并行调用多个服务器，只要一个成功即返回。通常用于实时性要求较高的读操作，但需要浪费更多服务资源。可通过 forks=“2” 来设置最大并行数。
>
> `Broadcast Cluster:`广播调用所有提供者，逐个调用，任意一台报错则报错。通常用于通知所有提供者更新缓存或日志等本地资源信息。

### 16.7 Dubbo 服务如何做降级？

> 1. Dubbo 原生自带的服务降级功能
> 2. 引入支持服务降级的组件 比如 Alibaba Sentinel

### 16.8 Dubbo 如何做限流？

> 1. Dubbo 原生自带的限流功能,通过 TpsLimitFilter 实现，仅适用于服务提供者
> 2. 引入支持限流的组件 例如`Sentine`

### 16.9 如何自己设计一个类似 Dubbo 的 RPC 框架？

> 举个栗子，我给大家说个最简单的回答思路：
>
> 1. 上来你的服务就得去注册中心注册吧，你是不是得有个注册中心，保留各个服务的信心，可以用 zookeeper 来做，对吧。
>
> 2. 然后你的消费者需要去注册中心拿对应的服务信息吧，对吧，而且每个服务可能会存在于多台机器上。
>
> 3. 接着你就该发起一次请求了，咋发起？当然是基于动态代理了，你面向接口获取到一个动态代理，这个动态代理就是接口在本地的一个代理，然后这个代理会找到服务对应的机器地址。
>
> 4. 然后找哪个机器发送请求？那肯定得有个负载均衡算法了，比如最简单的可以随机轮询是不是。
>
> 5. 接着找到一台机器，就可以跟它发送请求了，第一个问题咋发送？你可以说用 netty 了，nio 方式；第二个问题发送啥格式数据？你可以说用 hessian 序列化协议了，或者是别的，对吧。然后请求过去了。
>
> 6. 服务器那边一样的，需要针对你自己的服务生成一个动态代理，监听某个网络端口了，然后代理你本地的服务代码。接收到请求的时候，就调用对应的服务代码，对吧。
>
>    这就是一个最最基本的 rpc 框架的思路，先不说你有多牛逼的技术功底，哪怕这个最简单的思路你先给出来行不行？

### 16.10 dubbo SPI 机制 与 JAVA SPI？

> https://my.oschina.net/pingpangkuangmo/blog/508963

